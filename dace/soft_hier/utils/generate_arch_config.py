#!/usr/bin/env python3

def generate_arg_cfg(
    output_path="generated_arch.py",
    num_cluster_x=8,
    num_cluster_y=8,
    num_core_per_cluster=4,
    cluster_tcdm_bank_width=64,
    cluster_tcdm_bank_nb=64,
    cluster_tcdm_base="0x00000000",
    cluster_tcdm_size="0x00040000",
    cluster_tcdm_remote="0x30000000",
    cluster_stack_base="0x10000000",
    cluster_stack_size="0x00020000",
    cluster_zomem_base="0x18000000",
    cluster_zomem_size="0x00020000",
    cluster_reg_base="0x20000000",
    cluster_reg_size="0x00000200",
    spatz_num_vlsu_port=8,
    spatz_num_function_unit=8,
    redmule_ce_height=64,
    redmule_ce_width=16,
    redmule_ce_pipe=3,
    redmule_elem_size=2,
    redmule_queue_depth=1,
    redmule_reg_base="0x20020000",
    redmule_reg_size="0x00000200",
    multi_idma_enable=1,
    idma_outstand_txn=16,
    idma_outstand_burst=256,
    hbm_start_base="0xc0000000",
    hbm_node_addr_space="0x20000000",
    num_node_per_ctrl=1,
    hbm_placement="8,0,0,8",
    hbm_edge_interleaving=0,
    noc_outstanding=64,
    noc_link_width=1024,
    instruction_mem_base="0x80000000",
    instruction_mem_size="0x00010000",
    soc_register_base="0x90000000",
    soc_register_size="0x00010000",
    soc_register_eoc="0x90000000",
    soc_register_wakeup="0x90000004",
    sync_base="0x50000000",
    sync_interleave="0x00000080",
    sync_special_mem="0x00000040"
):
    # Process hbm_placement from string to a list (e.g., "4,0,0,4" -> ["4", "0", "0", "4"])
    hbm_placement_list = [p.strip() for p in hbm_placement.split(",")]

    code = f'''"""
Auto-generated FlexClusterArch class
------------------------------------
This file was generated by the generate_arg_cfg function.
"""

class FlexClusterArch:

    def __init__(self):

        # Cluster
        self.num_cluster_x           = {num_cluster_x}
        self.num_cluster_y           = {num_cluster_y}
        self.num_core_per_cluster    = {num_core_per_cluster}

        self.cluster_tcdm_bank_width = {cluster_tcdm_bank_width}
        self.cluster_tcdm_bank_nb    = {cluster_tcdm_bank_nb}

        self.cluster_tcdm_base       = {cluster_tcdm_base}
        self.cluster_tcdm_size       = {cluster_tcdm_size}
        self.cluster_tcdm_remote     = {cluster_tcdm_remote}

        self.cluster_stack_base      = {cluster_stack_base}
        self.cluster_stack_size      = {cluster_stack_size}

        self.cluster_zomem_base      = {cluster_zomem_base}
        self.cluster_zomem_size      = {cluster_zomem_size}

        self.cluster_reg_base        = {cluster_reg_base}
        self.cluster_reg_size        = {cluster_reg_size}

        # Spatz Vector Unit
        self.spatz_attaced_core_list = []  # Default empty
        self.spatz_num_vlsu_port     = {spatz_num_vlsu_port}
        self.spatz_num_function_unit = {spatz_num_function_unit}

        # RedMule
        self.redmule_ce_height       = {redmule_ce_height}
        self.redmule_ce_width        = {redmule_ce_width}
        self.redmule_ce_pipe         = {redmule_ce_pipe}
        self.redmule_elem_size       = {redmule_elem_size}
        self.redmule_queue_depth     = {redmule_queue_depth}
        self.redmule_reg_base        = {redmule_reg_base}
        self.redmule_reg_size        = {redmule_reg_size}

        # IDMA
        self.multi_idma_enable       = {multi_idma_enable}
        self.idma_outstand_txn       = {idma_outstand_txn}
        self.idma_outstand_burst     = {idma_outstand_burst}

        # HBM
        self.hbm_start_base          = {hbm_start_base}
        self.hbm_node_addr_space     = {hbm_node_addr_space}
        self.num_node_per_ctrl       = {num_node_per_ctrl}
        self.hbm_chan_placement      = [{", ".join(hbm_placement_list)}]

        # NoC
        self.noc_outstanding         = {noc_outstanding}
        self.noc_link_width          = {noc_link_width}

        # System
        self.instruction_mem_base    = {instruction_mem_base}
        self.instruction_mem_size    = {instruction_mem_size}

        self.soc_register_base       = {soc_register_base}
        self.soc_register_size       = {soc_register_size}
        self.soc_register_eoc        = {soc_register_eoc}
        self.soc_register_wakeup     = {soc_register_wakeup}

        # Synchronization
        self.sync_base               = {sync_base}
        self.sync_interleave         = {sync_interleave}
        self.sync_special_mem        = {sync_special_mem}
'''

    with open(output_path, "w") as f:
        f.write(code)

    print(f"\n[INFO] The file '{output_path}' has been created.\n")


def _check_combo(combo, tcdm_usage_func=None):
    '''
    Check if the combination is valid
    '''
    (
        M_val,
        N_val,
        K_val,
        hwM,
        hwN,
        hwK,
        thread_group_dims,
        tcdm_size
    ) = combo
    # print(f"Checking combo: {combo}")
    dim_x = thread_group_dims[0]
    dim_y = thread_group_dims[1]
    
    if M_val % hwM != 0:
        return False
    if N_val % hwN != 0:
        return False
    if K_val % hwK != 0:
        return False
    if M_val % dim_x != 0:
        return False
    if N_val % dim_y != 0:
        return False
    if M_val % (hwM * dim_x) != 0:
        return False
    if N_val % (hwN * dim_y) != 0:
        return False
    if (hwM * dim_x) > M_val:
        return False
    if (hwN * dim_y) > N_val:
        return False
    
    # Use provided function or default calculation
    if tcdm_usage_func is None:
        tcdm_usage_func = lambda m, n, k: 2 * (2 * m * k + 2 * k * n + m * n)
    
    tcdm_usage = tcdm_usage_func(hwM, hwN, hwK)
    if tcdm_usage > tcdm_size:
        return False
    if tcdm_usage < (tcdm_size // 2):
        if (hwM * dim_x >= M_val // 2) and (hwN * dim_y >= N_val // 2):
            pass
        else:   
            return False
    return True


def generate_tiling(M_val, N_val, K_val, thread_group_dims, tcdm_size, 
                    elem_size=1,
                    tcdm_usage_func=None, 
                    OI_func_type=1, 
                    min_tiling_size=64, 
                    redmule_h=64, redmule_w=16, hbm_bw=512):
    dim_m, dim_n = thread_group_dims
    num_clusters = dim_m * dim_n
    peak_performance = 2 * dim_m * dim_n * redmule_h * redmule_w

    ridge_OI = peak_performance / hbm_bw
    print(f"Ridge OI: {ridge_OI}")

    #TODO: whether to remap the thread group dimensions
    if min_tiling_size * dim_m > M_val and min_tiling_size * dim_n > N_val:
        raise ValueError("M and N must be divisible by the thread group dimensions")

    # Generate lists of thread group dimensions
    dim_x_list  = [dim_m]
    dim_y_list  = [dim_n]
    if min_tiling_size * dim_m > M_val:
        dim_x_list = [2**i for i in range(0, 6) if 2**i <= M_val // min_tiling_size]
        dim_y_list = [num_clusters // dim_x for dim_x in dim_x_list]
    elif min_tiling_size * dim_n > N_val:
        dim_y_list = [2**i for i in range(0, 6) if 2**i <= N_val // min_tiling_size]
        dim_x_list = [num_clusters // dim_y for dim_y in dim_y_list]


    print(f"dim_x_list: {dim_x_list}")
    print(f"dim_y_list: {dim_y_list}")

    all_combos = []

    for (dim_x, dim_y) in zip(dim_x_list, dim_y_list):
        # Default TCDM usage calculation if none provided
        if tcdm_usage_func is None:
            tcdm_usage_func = lambda m, n, k: elem_size * (2 * m * k + 2 * k * n + m * n)
        
        if OI_func_type is 0:
            OI_func = lambda m, n, k: 2 * m * n * k / (elem_size * (m * n + m * k + n * k))
        elif OI_func_type is 1:
            OI_func = lambda m, n, k: 2 * dim_x * dim_y * m * n * k / (elem_size * 
                                                                (dim_x * dim_y * m * n + 
                                                                dim_x * m * k + 
                                                                dim_y * n * k))

        max_OI_func = lambda m, n, k: 2 * m * n * k / (elem_size * (m * n + m * k + n * k))
        # Unpack thread group dimensions
        
        combos = []

        def factors(n):
            result = []
            # iterate up to the square root of n
            for i in range(1, int(n ** 0.5) + 1):
                if n % i == 0:
                    result.append(i)
                    if i != n // i:
                        result.append(n // i)
            return sorted(result)
        
        if (M_val % dim_x != 0) or (N_val % dim_y != 0):
            raise ValueError("M and N must be divisible by the thread group dimensions")

        # Generate lists of hardware tile sizes
        hw_M_list = [i for i in factors(M_val // dim_x) if i >= min_tiling_size]
        hw_N_list = [i for i in factors(N_val // dim_y) if i >= min_tiling_size]
        if len(hw_N_list) == 0:
            hw_N_list = [max([i for i in factors(N_val // dim_y) if i < min_tiling_size])]
        
        hw_K_list = [i for i in factors(K_val) if i >= min_tiling_size]

        print(f"hw_M_list: {hw_M_list}")
        print(f"hw_N_list: {hw_N_list}")
        print(f"hw_K_list: {hw_K_list}")

        # Iterate over all combinations of hardware tile sizes.
        for hw_M in hw_M_list:
            for hw_N in hw_N_list:
                for hw_K in hw_K_list:
                    # If the estimated memory footprint exceeds TCDM size,
                    # break out of the innermost loop (assuming hw_K_list is in ascending order).
                    if tcdm_usage_func(hw_M, hw_N, hw_K) > tcdm_size:
                        break
                    OI = OI_func(hw_M, hw_N, K_val)
                    max_OI = max_OI_func(M_val, N_val, K_val)
                    print(f"OI: {OI}, max_OI: {max_OI}")
                    # If the OI is less than the ridge OI, skip this combination
                    if OI < ridge_OI and max_OI > ridge_OI:
                        continue
                    # Build the configuration tuple.
                    combo = (M_val, N_val, K_val, hw_M, hw_N, hw_K,
                            (dim_x, dim_y), tcdm_size)
                    if _check_combo(combo, tcdm_usage_func):
                        combos.append(combo)

        # Filter combinations based on the maximum product of hw_M and hw_N.
        if combos:
            max_OI = max([OI_func(combo[3], combo[4], combo[2]) for combo in combos
                        if _check_combo(combo, tcdm_usage_func)])
            filtered_combos = [combo for combo in combos if (OI_func(combo[3], combo[4], combo[2])) >= max_OI/8]
            all_combos.extend(filtered_combos)

    return all_combos

